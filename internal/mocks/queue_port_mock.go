// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	ports "github.com/eleven-am/graft/internal/ports"
	mock "github.com/stretchr/testify/mock"
)

// MockQueuePort is an autogenerated mock type for the QueuePort type
type MockQueuePort struct {
	mock.Mock
}

type MockQueuePort_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQueuePort) EXPECT() *MockQueuePort_Expecter {
	return &MockQueuePort_Expecter{mock: &_m.Mock}
}

// Claim provides a mock function with no fields
func (_m *MockQueuePort) Claim() ([]byte, string, bool, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Claim")
	}

	var r0 []byte
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func() ([]byte, string, bool, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() bool); ok {
		r2 = rf()
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func() error); ok {
		r3 = rf()
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockQueuePort_Claim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Claim'
type MockQueuePort_Claim_Call struct {
	*mock.Call
}

// Claim is a helper method to define mock.On call
func (_e *MockQueuePort_Expecter) Claim() *MockQueuePort_Claim_Call {
	return &MockQueuePort_Claim_Call{Call: _e.mock.On("Claim")}
}

func (_c *MockQueuePort_Claim_Call) Run(run func()) *MockQueuePort_Claim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockQueuePort_Claim_Call) Return(item []byte, claimID string, exists bool, err error) *MockQueuePort_Claim_Call {
	_c.Call.Return(item, claimID, exists, err)
	return _c
}

func (_c *MockQueuePort_Claim_Call) RunAndReturn(run func() ([]byte, string, bool, error)) *MockQueuePort_Claim_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with no fields
func (_m *MockQueuePort) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueuePort_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockQueuePort_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockQueuePort_Expecter) Close() *MockQueuePort_Close_Call {
	return &MockQueuePort_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockQueuePort_Close_Call) Run(run func()) *MockQueuePort_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockQueuePort_Close_Call) Return(_a0 error) *MockQueuePort_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_Close_Call) RunAndReturn(run func() error) *MockQueuePort_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Complete provides a mock function with given fields: claimID
func (_m *MockQueuePort) Complete(claimID string) error {
	ret := _m.Called(claimID)

	if len(ret) == 0 {
		panic("no return value specified for Complete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(claimID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueuePort_Complete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Complete'
type MockQueuePort_Complete_Call struct {
	*mock.Call
}

// Complete is a helper method to define mock.On call
//   - claimID string
func (_e *MockQueuePort_Expecter) Complete(claimID interface{}) *MockQueuePort_Complete_Call {
	return &MockQueuePort_Complete_Call{Call: _e.mock.On("Complete", claimID)}
}

func (_c *MockQueuePort_Complete_Call) Run(run func(claimID string)) *MockQueuePort_Complete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_Complete_Call) Return(_a0 error) *MockQueuePort_Complete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_Complete_Call) RunAndReturn(run func(string) error) *MockQueuePort_Complete_Call {
	_c.Call.Return(run)
	return _c
}

// Enqueue provides a mock function with given fields: item
func (_m *MockQueuePort) Enqueue(item []byte) error {
	ret := _m.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Enqueue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(item)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueuePort_Enqueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enqueue'
type MockQueuePort_Enqueue_Call struct {
	*mock.Call
}

// Enqueue is a helper method to define mock.On call
//   - item []byte
func (_e *MockQueuePort_Expecter) Enqueue(item interface{}) *MockQueuePort_Enqueue_Call {
	return &MockQueuePort_Enqueue_Call{Call: _e.mock.On("Enqueue", item)}
}

func (_c *MockQueuePort_Enqueue_Call) Run(run func(item []byte)) *MockQueuePort_Enqueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockQueuePort_Enqueue_Call) Return(_a0 error) *MockQueuePort_Enqueue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_Enqueue_Call) RunAndReturn(run func([]byte) error) *MockQueuePort_Enqueue_Call {
	_c.Call.Return(run)
	return _c
}

// GetClaimedItemsWithPrefix provides a mock function with given fields: dataPrefix
func (_m *MockQueuePort) GetClaimedItemsWithPrefix(dataPrefix string) ([]ports.ClaimedItem, error) {
	ret := _m.Called(dataPrefix)

	if len(ret) == 0 {
		panic("no return value specified for GetClaimedItemsWithPrefix")
	}

	var r0 []ports.ClaimedItem
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]ports.ClaimedItem, error)); ok {
		return rf(dataPrefix)
	}
	if rf, ok := ret.Get(0).(func(string) []ports.ClaimedItem); ok {
		r0 = rf(dataPrefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ports.ClaimedItem)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dataPrefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_GetClaimedItemsWithPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClaimedItemsWithPrefix'
type MockQueuePort_GetClaimedItemsWithPrefix_Call struct {
	*mock.Call
}

// GetClaimedItemsWithPrefix is a helper method to define mock.On call
//   - dataPrefix string
func (_e *MockQueuePort_Expecter) GetClaimedItemsWithPrefix(dataPrefix interface{}) *MockQueuePort_GetClaimedItemsWithPrefix_Call {
	return &MockQueuePort_GetClaimedItemsWithPrefix_Call{Call: _e.mock.On("GetClaimedItemsWithPrefix", dataPrefix)}
}

func (_c *MockQueuePort_GetClaimedItemsWithPrefix_Call) Run(run func(dataPrefix string)) *MockQueuePort_GetClaimedItemsWithPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_GetClaimedItemsWithPrefix_Call) Return(_a0 []ports.ClaimedItem, _a1 error) *MockQueuePort_GetClaimedItemsWithPrefix_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_GetClaimedItemsWithPrefix_Call) RunAndReturn(run func(string) ([]ports.ClaimedItem, error)) *MockQueuePort_GetClaimedItemsWithPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeadLetterItems provides a mock function with given fields: limit
func (_m *MockQueuePort) GetDeadLetterItems(limit int) ([]ports.DeadLetterItem, error) {
	ret := _m.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for GetDeadLetterItems")
	}

	var r0 []ports.DeadLetterItem
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]ports.DeadLetterItem, error)); ok {
		return rf(limit)
	}
	if rf, ok := ret.Get(0).(func(int) []ports.DeadLetterItem); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ports.DeadLetterItem)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_GetDeadLetterItems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeadLetterItems'
type MockQueuePort_GetDeadLetterItems_Call struct {
	*mock.Call
}

// GetDeadLetterItems is a helper method to define mock.On call
//   - limit int
func (_e *MockQueuePort_Expecter) GetDeadLetterItems(limit interface{}) *MockQueuePort_GetDeadLetterItems_Call {
	return &MockQueuePort_GetDeadLetterItems_Call{Call: _e.mock.On("GetDeadLetterItems", limit)}
}

func (_c *MockQueuePort_GetDeadLetterItems_Call) Run(run func(limit int)) *MockQueuePort_GetDeadLetterItems_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockQueuePort_GetDeadLetterItems_Call) Return(_a0 []ports.DeadLetterItem, _a1 error) *MockQueuePort_GetDeadLetterItems_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_GetDeadLetterItems_Call) RunAndReturn(run func(int) ([]ports.DeadLetterItem, error)) *MockQueuePort_GetDeadLetterItems_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeadLetterSize provides a mock function with no fields
func (_m *MockQueuePort) GetDeadLetterSize() (int, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetDeadLetterSize")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func() (int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_GetDeadLetterSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeadLetterSize'
type MockQueuePort_GetDeadLetterSize_Call struct {
	*mock.Call
}

// GetDeadLetterSize is a helper method to define mock.On call
func (_e *MockQueuePort_Expecter) GetDeadLetterSize() *MockQueuePort_GetDeadLetterSize_Call {
	return &MockQueuePort_GetDeadLetterSize_Call{Call: _e.mock.On("GetDeadLetterSize")}
}

func (_c *MockQueuePort_GetDeadLetterSize_Call) Run(run func()) *MockQueuePort_GetDeadLetterSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockQueuePort_GetDeadLetterSize_Call) Return(_a0 int, _a1 error) *MockQueuePort_GetDeadLetterSize_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_GetDeadLetterSize_Call) RunAndReturn(run func() (int, error)) *MockQueuePort_GetDeadLetterSize_Call {
	_c.Call.Return(run)
	return _c
}

// GetItemsWithPrefix provides a mock function with given fields: dataPrefix
func (_m *MockQueuePort) GetItemsWithPrefix(dataPrefix string) ([][]byte, error) {
	ret := _m.Called(dataPrefix)

	if len(ret) == 0 {
		panic("no return value specified for GetItemsWithPrefix")
	}

	var r0 [][]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]byte, error)); ok {
		return rf(dataPrefix)
	}
	if rf, ok := ret.Get(0).(func(string) [][]byte); ok {
		r0 = rf(dataPrefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dataPrefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_GetItemsWithPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetItemsWithPrefix'
type MockQueuePort_GetItemsWithPrefix_Call struct {
	*mock.Call
}

// GetItemsWithPrefix is a helper method to define mock.On call
//   - dataPrefix string
func (_e *MockQueuePort_Expecter) GetItemsWithPrefix(dataPrefix interface{}) *MockQueuePort_GetItemsWithPrefix_Call {
	return &MockQueuePort_GetItemsWithPrefix_Call{Call: _e.mock.On("GetItemsWithPrefix", dataPrefix)}
}

func (_c *MockQueuePort_GetItemsWithPrefix_Call) Run(run func(dataPrefix string)) *MockQueuePort_GetItemsWithPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_GetItemsWithPrefix_Call) Return(_a0 [][]byte, _a1 error) *MockQueuePort_GetItemsWithPrefix_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_GetItemsWithPrefix_Call) RunAndReturn(run func(string) ([][]byte, error)) *MockQueuePort_GetItemsWithPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// HasClaimedItemsWithPrefix provides a mock function with given fields: dataPrefix
func (_m *MockQueuePort) HasClaimedItemsWithPrefix(dataPrefix string) (bool, error) {
	ret := _m.Called(dataPrefix)

	if len(ret) == 0 {
		panic("no return value specified for HasClaimedItemsWithPrefix")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(dataPrefix)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(dataPrefix)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dataPrefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_HasClaimedItemsWithPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasClaimedItemsWithPrefix'
type MockQueuePort_HasClaimedItemsWithPrefix_Call struct {
	*mock.Call
}

// HasClaimedItemsWithPrefix is a helper method to define mock.On call
//   - dataPrefix string
func (_e *MockQueuePort_Expecter) HasClaimedItemsWithPrefix(dataPrefix interface{}) *MockQueuePort_HasClaimedItemsWithPrefix_Call {
	return &MockQueuePort_HasClaimedItemsWithPrefix_Call{Call: _e.mock.On("HasClaimedItemsWithPrefix", dataPrefix)}
}

func (_c *MockQueuePort_HasClaimedItemsWithPrefix_Call) Run(run func(dataPrefix string)) *MockQueuePort_HasClaimedItemsWithPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_HasClaimedItemsWithPrefix_Call) Return(_a0 bool, _a1 error) *MockQueuePort_HasClaimedItemsWithPrefix_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_HasClaimedItemsWithPrefix_Call) RunAndReturn(run func(string) (bool, error)) *MockQueuePort_HasClaimedItemsWithPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// HasItemsWithPrefix provides a mock function with given fields: dataPrefix
func (_m *MockQueuePort) HasItemsWithPrefix(dataPrefix string) (bool, error) {
	ret := _m.Called(dataPrefix)

	if len(ret) == 0 {
		panic("no return value specified for HasItemsWithPrefix")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(dataPrefix)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(dataPrefix)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dataPrefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_HasItemsWithPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasItemsWithPrefix'
type MockQueuePort_HasItemsWithPrefix_Call struct {
	*mock.Call
}

// HasItemsWithPrefix is a helper method to define mock.On call
//   - dataPrefix string
func (_e *MockQueuePort_Expecter) HasItemsWithPrefix(dataPrefix interface{}) *MockQueuePort_HasItemsWithPrefix_Call {
	return &MockQueuePort_HasItemsWithPrefix_Call{Call: _e.mock.On("HasItemsWithPrefix", dataPrefix)}
}

func (_c *MockQueuePort_HasItemsWithPrefix_Call) Run(run func(dataPrefix string)) *MockQueuePort_HasItemsWithPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_HasItemsWithPrefix_Call) Return(_a0 bool, _a1 error) *MockQueuePort_HasItemsWithPrefix_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_HasItemsWithPrefix_Call) RunAndReturn(run func(string) (bool, error)) *MockQueuePort_HasItemsWithPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// Peek provides a mock function with no fields
func (_m *MockQueuePort) Peek() ([]byte, bool, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Peek")
	}

	var r0 []byte
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func() ([]byte, bool, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func() error); ok {
		r2 = rf()
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockQueuePort_Peek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Peek'
type MockQueuePort_Peek_Call struct {
	*mock.Call
}

// Peek is a helper method to define mock.On call
func (_e *MockQueuePort_Expecter) Peek() *MockQueuePort_Peek_Call {
	return &MockQueuePort_Peek_Call{Call: _e.mock.On("Peek")}
}

func (_c *MockQueuePort_Peek_Call) Run(run func()) *MockQueuePort_Peek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockQueuePort_Peek_Call) Return(item []byte, exists bool, err error) *MockQueuePort_Peek_Call {
	_c.Call.Return(item, exists, err)
	return _c
}

func (_c *MockQueuePort_Peek_Call) RunAndReturn(run func() ([]byte, bool, error)) *MockQueuePort_Peek_Call {
	_c.Call.Return(run)
	return _c
}

// Release provides a mock function with given fields: claimID
func (_m *MockQueuePort) Release(claimID string) error {
	ret := _m.Called(claimID)

	if len(ret) == 0 {
		panic("no return value specified for Release")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(claimID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueuePort_Release_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Release'
type MockQueuePort_Release_Call struct {
	*mock.Call
}

// Release is a helper method to define mock.On call
//   - claimID string
func (_e *MockQueuePort_Expecter) Release(claimID interface{}) *MockQueuePort_Release_Call {
	return &MockQueuePort_Release_Call{Call: _e.mock.On("Release", claimID)}
}

func (_c *MockQueuePort_Release_Call) Run(run func(claimID string)) *MockQueuePort_Release_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_Release_Call) Return(_a0 error) *MockQueuePort_Release_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_Release_Call) RunAndReturn(run func(string) error) *MockQueuePort_Release_Call {
	_c.Call.Return(run)
	return _c
}

// RetryFromDeadLetter provides a mock function with given fields: itemID
func (_m *MockQueuePort) RetryFromDeadLetter(itemID string) error {
	ret := _m.Called(itemID)

	if len(ret) == 0 {
		panic("no return value specified for RetryFromDeadLetter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(itemID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueuePort_RetryFromDeadLetter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryFromDeadLetter'
type MockQueuePort_RetryFromDeadLetter_Call struct {
	*mock.Call
}

// RetryFromDeadLetter is a helper method to define mock.On call
//   - itemID string
func (_e *MockQueuePort_Expecter) RetryFromDeadLetter(itemID interface{}) *MockQueuePort_RetryFromDeadLetter_Call {
	return &MockQueuePort_RetryFromDeadLetter_Call{Call: _e.mock.On("RetryFromDeadLetter", itemID)}
}

func (_c *MockQueuePort_RetryFromDeadLetter_Call) Run(run func(itemID string)) *MockQueuePort_RetryFromDeadLetter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockQueuePort_RetryFromDeadLetter_Call) Return(_a0 error) *MockQueuePort_RetryFromDeadLetter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_RetryFromDeadLetter_Call) RunAndReturn(run func(string) error) *MockQueuePort_RetryFromDeadLetter_Call {
	_c.Call.Return(run)
	return _c
}

// SendToDeadLetter provides a mock function with given fields: item, reason
func (_m *MockQueuePort) SendToDeadLetter(item []byte, reason string) error {
	ret := _m.Called(item, reason)

	if len(ret) == 0 {
		panic("no return value specified for SendToDeadLetter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, string) error); ok {
		r0 = rf(item, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueuePort_SendToDeadLetter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendToDeadLetter'
type MockQueuePort_SendToDeadLetter_Call struct {
	*mock.Call
}

// SendToDeadLetter is a helper method to define mock.On call
//   - item []byte
//   - reason string
func (_e *MockQueuePort_Expecter) SendToDeadLetter(item interface{}, reason interface{}) *MockQueuePort_SendToDeadLetter_Call {
	return &MockQueuePort_SendToDeadLetter_Call{Call: _e.mock.On("SendToDeadLetter", item, reason)}
}

func (_c *MockQueuePort_SendToDeadLetter_Call) Run(run func(item []byte, reason string)) *MockQueuePort_SendToDeadLetter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(string))
	})
	return _c
}

func (_c *MockQueuePort_SendToDeadLetter_Call) Return(_a0 error) *MockQueuePort_SendToDeadLetter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_SendToDeadLetter_Call) RunAndReturn(run func([]byte, string) error) *MockQueuePort_SendToDeadLetter_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function with no fields
func (_m *MockQueuePort) Size() (int, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func() (int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueuePort_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockQueuePort_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockQueuePort_Expecter) Size() *MockQueuePort_Size_Call {
	return &MockQueuePort_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockQueuePort_Size_Call) Run(run func()) *MockQueuePort_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockQueuePort_Size_Call) Return(_a0 int, _a1 error) *MockQueuePort_Size_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueuePort_Size_Call) RunAndReturn(run func() (int, error)) *MockQueuePort_Size_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForItem provides a mock function with given fields: ctx
func (_m *MockQueuePort) WaitForItem(ctx context.Context) <-chan struct{} {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WaitForItem")
	}

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan struct{}); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// MockQueuePort_WaitForItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForItem'
type MockQueuePort_WaitForItem_Call struct {
	*mock.Call
}

// WaitForItem is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueuePort_Expecter) WaitForItem(ctx interface{}) *MockQueuePort_WaitForItem_Call {
	return &MockQueuePort_WaitForItem_Call{Call: _e.mock.On("WaitForItem", ctx)}
}

func (_c *MockQueuePort_WaitForItem_Call) Run(run func(ctx context.Context)) *MockQueuePort_WaitForItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueuePort_WaitForItem_Call) Return(_a0 <-chan struct{}) *MockQueuePort_WaitForItem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueuePort_WaitForItem_Call) RunAndReturn(run func(context.Context) <-chan struct{}) *MockQueuePort_WaitForItem_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQueuePort creates a new instance of MockQueuePort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQueuePort(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQueuePort {
	mock := &MockQueuePort{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
