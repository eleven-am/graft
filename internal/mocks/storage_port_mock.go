// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	io "io"

	ports "github.com/eleven-am/graft/internal/ports"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockStoragePort is an autogenerated mock type for the StoragePort type
type MockStoragePort struct {
	mock.Mock
}

type MockStoragePort_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStoragePort) EXPECT() *MockStoragePort_Expecter {
	return &MockStoragePort_Expecter{mock: &_m.Mock}
}

// AtomicIncrement provides a mock function with given fields: key
func (_m *MockStoragePort) AtomicIncrement(key string) (int64, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for AtomicIncrement")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int64, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) int64); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_AtomicIncrement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtomicIncrement'
type MockStoragePort_AtomicIncrement_Call struct {
	*mock.Call
}

// AtomicIncrement is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) AtomicIncrement(key interface{}) *MockStoragePort_AtomicIncrement_Call {
	return &MockStoragePort_AtomicIncrement_Call{Call: _e.mock.On("AtomicIncrement", key)}
}

func (_c *MockStoragePort_AtomicIncrement_Call) Run(run func(key string)) *MockStoragePort_AtomicIncrement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_AtomicIncrement_Call) Return(newValue int64, err error) *MockStoragePort_AtomicIncrement_Call {
	_c.Call.Return(newValue, err)
	return _c
}

func (_c *MockStoragePort_AtomicIncrement_Call) RunAndReturn(run func(string) (int64, error)) *MockStoragePort_AtomicIncrement_Call {
	_c.Call.Return(run)
	return _c
}

// BatchWrite provides a mock function with given fields: ops
func (_m *MockStoragePort) BatchWrite(ops []ports.WriteOp) error {
	ret := _m.Called(ops)

	if len(ret) == 0 {
		panic("no return value specified for BatchWrite")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]ports.WriteOp) error); ok {
		r0 = rf(ops)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_BatchWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchWrite'
type MockStoragePort_BatchWrite_Call struct {
	*mock.Call
}

// BatchWrite is a helper method to define mock.On call
//   - ops []ports.WriteOp
func (_e *MockStoragePort_Expecter) BatchWrite(ops interface{}) *MockStoragePort_BatchWrite_Call {
	return &MockStoragePort_BatchWrite_Call{Call: _e.mock.On("BatchWrite", ops)}
}

func (_c *MockStoragePort_BatchWrite_Call) Run(run func(ops []ports.WriteOp)) *MockStoragePort_BatchWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]ports.WriteOp))
	})
	return _c
}

func (_c *MockStoragePort_BatchWrite_Call) Return(_a0 error) *MockStoragePort_BatchWrite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_BatchWrite_Call) RunAndReturn(run func([]ports.WriteOp) error) *MockStoragePort_BatchWrite_Call {
	_c.Call.Return(run)
	return _c
}

// CleanExpired provides a mock function with no fields
func (_m *MockStoragePort) CleanExpired() (int, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CleanExpired")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func() (int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_CleanExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanExpired'
type MockStoragePort_CleanExpired_Call struct {
	*mock.Call
}

// CleanExpired is a helper method to define mock.On call
func (_e *MockStoragePort_Expecter) CleanExpired() *MockStoragePort_CleanExpired_Call {
	return &MockStoragePort_CleanExpired_Call{Call: _e.mock.On("CleanExpired")}
}

func (_c *MockStoragePort_CleanExpired_Call) Run(run func()) *MockStoragePort_CleanExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStoragePort_CleanExpired_Call) Return(cleanedCount int, err error) *MockStoragePort_CleanExpired_Call {
	_c.Call.Return(cleanedCount, err)
	return _c
}

func (_c *MockStoragePort_CleanExpired_Call) RunAndReturn(run func() (int, error)) *MockStoragePort_CleanExpired_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with no fields
func (_m *MockStoragePort) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockStoragePort_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockStoragePort_Expecter) Close() *MockStoragePort_Close_Call {
	return &MockStoragePort_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockStoragePort_Close_Call) Run(run func()) *MockStoragePort_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStoragePort_Close_Call) Return(_a0 error) *MockStoragePort_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_Close_Call) RunAndReturn(run func() error) *MockStoragePort_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CountPrefix provides a mock function with given fields: prefix
func (_m *MockStoragePort) CountPrefix(prefix string) (int, error) {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for CountPrefix")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int, error)); ok {
		return rf(prefix)
	}
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(prefix)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(prefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_CountPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountPrefix'
type MockStoragePort_CountPrefix_Call struct {
	*mock.Call
}

// CountPrefix is a helper method to define mock.On call
//   - prefix string
func (_e *MockStoragePort_Expecter) CountPrefix(prefix interface{}) *MockStoragePort_CountPrefix_Call {
	return &MockStoragePort_CountPrefix_Call{Call: _e.mock.On("CountPrefix", prefix)}
}

func (_c *MockStoragePort_CountPrefix_Call) Run(run func(prefix string)) *MockStoragePort_CountPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_CountPrefix_Call) Return(count int, err error) *MockStoragePort_CountPrefix_Call {
	_c.Call.Return(count, err)
	return _c
}

func (_c *MockStoragePort_CountPrefix_Call) RunAndReturn(run func(string) (int, error)) *MockStoragePort_CountPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCompressedSnapshot provides a mock function with no fields
func (_m *MockStoragePort) CreateCompressedSnapshot() (io.ReadCloser, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CreateCompressedSnapshot")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func() (io.ReadCloser, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() io.ReadCloser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_CreateCompressedSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCompressedSnapshot'
type MockStoragePort_CreateCompressedSnapshot_Call struct {
	*mock.Call
}

// CreateCompressedSnapshot is a helper method to define mock.On call
func (_e *MockStoragePort_Expecter) CreateCompressedSnapshot() *MockStoragePort_CreateCompressedSnapshot_Call {
	return &MockStoragePort_CreateCompressedSnapshot_Call{Call: _e.mock.On("CreateCompressedSnapshot")}
}

func (_c *MockStoragePort_CreateCompressedSnapshot_Call) Run(run func()) *MockStoragePort_CreateCompressedSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStoragePort_CreateCompressedSnapshot_Call) Return(_a0 io.ReadCloser, _a1 error) *MockStoragePort_CreateCompressedSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_CreateCompressedSnapshot_Call) RunAndReturn(run func() (io.ReadCloser, error)) *MockStoragePort_CreateCompressedSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnapshot provides a mock function with no fields
func (_m *MockStoragePort) CreateSnapshot() (io.ReadCloser, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func() (io.ReadCloser, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() io.ReadCloser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_CreateSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnapshot'
type MockStoragePort_CreateSnapshot_Call struct {
	*mock.Call
}

// CreateSnapshot is a helper method to define mock.On call
func (_e *MockStoragePort_Expecter) CreateSnapshot() *MockStoragePort_CreateSnapshot_Call {
	return &MockStoragePort_CreateSnapshot_Call{Call: _e.mock.On("CreateSnapshot")}
}

func (_c *MockStoragePort_CreateSnapshot_Call) Run(run func()) *MockStoragePort_CreateSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStoragePort_CreateSnapshot_Call) Return(_a0 io.ReadCloser, _a1 error) *MockStoragePort_CreateSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_CreateSnapshot_Call) RunAndReturn(run func() (io.ReadCloser, error)) *MockStoragePort_CreateSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: key
func (_m *MockStoragePort) Delete(key string) error {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockStoragePort_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) Delete(key interface{}) *MockStoragePort_Delete_Call {
	return &MockStoragePort_Delete_Call{Call: _e.mock.On("Delete", key)}
}

func (_c *MockStoragePort_Delete_Call) Run(run func(key string)) *MockStoragePort_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_Delete_Call) Return(_a0 error) *MockStoragePort_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_Delete_Call) RunAndReturn(run func(string) error) *MockStoragePort_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByPrefix provides a mock function with given fields: prefix
func (_m *MockStoragePort) DeleteByPrefix(prefix string) (int, error) {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByPrefix")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int, error)); ok {
		return rf(prefix)
	}
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(prefix)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(prefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_DeleteByPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByPrefix'
type MockStoragePort_DeleteByPrefix_Call struct {
	*mock.Call
}

// DeleteByPrefix is a helper method to define mock.On call
//   - prefix string
func (_e *MockStoragePort_Expecter) DeleteByPrefix(prefix interface{}) *MockStoragePort_DeleteByPrefix_Call {
	return &MockStoragePort_DeleteByPrefix_Call{Call: _e.mock.On("DeleteByPrefix", prefix)}
}

func (_c *MockStoragePort_DeleteByPrefix_Call) Run(run func(prefix string)) *MockStoragePort_DeleteByPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_DeleteByPrefix_Call) Return(deletedCount int, err error) *MockStoragePort_DeleteByPrefix_Call {
	_c.Call.Return(deletedCount, err)
	return _c
}

func (_c *MockStoragePort_DeleteByPrefix_Call) RunAndReturn(run func(string) (int, error)) *MockStoragePort_DeleteByPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: key
func (_m *MockStoragePort) Exists(key string) (bool, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockStoragePort_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) Exists(key interface{}) *MockStoragePort_Exists_Call {
	return &MockStoragePort_Exists_Call{Call: _e.mock.On("Exists", key)}
}

func (_c *MockStoragePort_Exists_Call) Run(run func(key string)) *MockStoragePort_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_Exists_Call) Return(_a0 bool, _a1 error) *MockStoragePort_Exists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_Exists_Call) RunAndReturn(run func(string) (bool, error)) *MockStoragePort_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireAt provides a mock function with given fields: key, expireTime
func (_m *MockStoragePort) ExpireAt(key string, expireTime time.Time) error {
	ret := _m.Called(key, expireTime)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, time.Time) error); ok {
		r0 = rf(key, expireTime)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_ExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireAt'
type MockStoragePort_ExpireAt_Call struct {
	*mock.Call
}

// ExpireAt is a helper method to define mock.On call
//   - key string
//   - expireTime time.Time
func (_e *MockStoragePort_Expecter) ExpireAt(key interface{}, expireTime interface{}) *MockStoragePort_ExpireAt_Call {
	return &MockStoragePort_ExpireAt_Call{Call: _e.mock.On("ExpireAt", key, expireTime)}
}

func (_c *MockStoragePort_ExpireAt_Call) Run(run func(key string, expireTime time.Time)) *MockStoragePort_ExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Time))
	})
	return _c
}

func (_c *MockStoragePort_ExpireAt_Call) Return(_a0 error) *MockStoragePort_ExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_ExpireAt_Call) RunAndReturn(run func(string, time.Time) error) *MockStoragePort_ExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: key
func (_m *MockStoragePort) Get(key string) ([]byte, int64, bool, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 int64
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, int64, bool, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) int64); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string) bool); ok {
		r2 = rf(key)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(string) error); ok {
		r3 = rf(key)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockStoragePort_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockStoragePort_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) Get(key interface{}) *MockStoragePort_Get_Call {
	return &MockStoragePort_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *MockStoragePort_Get_Call) Run(run func(key string)) *MockStoragePort_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_Get_Call) Return(value []byte, version int64, exists bool, err error) *MockStoragePort_Get_Call {
	_c.Call.Return(value, version, exists, err)
	return _c
}

func (_c *MockStoragePort_Get_Call) RunAndReturn(run func(string) ([]byte, int64, bool, error)) *MockStoragePort_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetadata provides a mock function with given fields: key
func (_m *MockStoragePort) GetMetadata(key string) (*ports.KeyMetadata, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 *ports.KeyMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*ports.KeyMetadata, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) *ports.KeyMetadata); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ports.KeyMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_GetMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetadata'
type MockStoragePort_GetMetadata_Call struct {
	*mock.Call
}

// GetMetadata is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) GetMetadata(key interface{}) *MockStoragePort_GetMetadata_Call {
	return &MockStoragePort_GetMetadata_Call{Call: _e.mock.On("GetMetadata", key)}
}

func (_c *MockStoragePort_GetMetadata_Call) Run(run func(key string)) *MockStoragePort_GetMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_GetMetadata_Call) Return(_a0 *ports.KeyMetadata, _a1 error) *MockStoragePort_GetMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_GetMetadata_Call) RunAndReturn(run func(string) (*ports.KeyMetadata, error)) *MockStoragePort_GetMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetNext provides a mock function with given fields: prefix
func (_m *MockStoragePort) GetNext(prefix string) (string, []byte, bool, error) {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for GetNext")
	}

	var r0 string
	var r1 []byte
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(string) (string, []byte, bool, error)); ok {
		return rf(prefix)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(prefix)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) []byte); ok {
		r1 = rf(prefix)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	if rf, ok := ret.Get(2).(func(string) bool); ok {
		r2 = rf(prefix)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(string) error); ok {
		r3 = rf(prefix)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockStoragePort_GetNext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNext'
type MockStoragePort_GetNext_Call struct {
	*mock.Call
}

// GetNext is a helper method to define mock.On call
//   - prefix string
func (_e *MockStoragePort_Expecter) GetNext(prefix interface{}) *MockStoragePort_GetNext_Call {
	return &MockStoragePort_GetNext_Call{Call: _e.mock.On("GetNext", prefix)}
}

func (_c *MockStoragePort_GetNext_Call) Run(run func(prefix string)) *MockStoragePort_GetNext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_GetNext_Call) Return(key string, value []byte, exists bool, err error) *MockStoragePort_GetNext_Call {
	_c.Call.Return(key, value, exists, err)
	return _c
}

func (_c *MockStoragePort_GetNext_Call) RunAndReturn(run func(string) (string, []byte, bool, error)) *MockStoragePort_GetNext_Call {
	_c.Call.Return(run)
	return _c
}

// GetNextAfter provides a mock function with given fields: prefix, afterKey
func (_m *MockStoragePort) GetNextAfter(prefix string, afterKey string) (string, []byte, bool, error) {
	ret := _m.Called(prefix, afterKey)

	if len(ret) == 0 {
		panic("no return value specified for GetNextAfter")
	}

	var r0 string
	var r1 []byte
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(string, string) (string, []byte, bool, error)); ok {
		return rf(prefix, afterKey)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, afterKey)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) []byte); ok {
		r1 = rf(prefix, afterKey)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	if rf, ok := ret.Get(2).(func(string, string) bool); ok {
		r2 = rf(prefix, afterKey)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(string, string) error); ok {
		r3 = rf(prefix, afterKey)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockStoragePort_GetNextAfter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextAfter'
type MockStoragePort_GetNextAfter_Call struct {
	*mock.Call
}

// GetNextAfter is a helper method to define mock.On call
//   - prefix string
//   - afterKey string
func (_e *MockStoragePort_Expecter) GetNextAfter(prefix interface{}, afterKey interface{}) *MockStoragePort_GetNextAfter_Call {
	return &MockStoragePort_GetNextAfter_Call{Call: _e.mock.On("GetNextAfter", prefix, afterKey)}
}

func (_c *MockStoragePort_GetNextAfter_Call) Run(run func(prefix string, afterKey string)) *MockStoragePort_GetNextAfter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockStoragePort_GetNextAfter_Call) Return(key string, value []byte, exists bool, err error) *MockStoragePort_GetNextAfter_Call {
	_c.Call.Return(key, value, exists, err)
	return _c
}

func (_c *MockStoragePort_GetNextAfter_Call) RunAndReturn(run func(string, string) (string, []byte, bool, error)) *MockStoragePort_GetNextAfter_Call {
	_c.Call.Return(run)
	return _c
}

// GetTTL provides a mock function with given fields: key
func (_m *MockStoragePort) GetTTL(key string) (time.Duration, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetTTL")
	}

	var r0 time.Duration
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (time.Duration, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) time.Duration); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_GetTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTTL'
type MockStoragePort_GetTTL_Call struct {
	*mock.Call
}

// GetTTL is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) GetTTL(key interface{}) *MockStoragePort_GetTTL_Call {
	return &MockStoragePort_GetTTL_Call{Call: _e.mock.On("GetTTL", key)}
}

func (_c *MockStoragePort_GetTTL_Call) Run(run func(key string)) *MockStoragePort_GetTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_GetTTL_Call) Return(_a0 time.Duration, _a1 error) *MockStoragePort_GetTTL_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_GetTTL_Call) RunAndReturn(run func(string) (time.Duration, error)) *MockStoragePort_GetTTL_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersion provides a mock function with given fields: key
func (_m *MockStoragePort) GetVersion(key string) (int64, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetVersion")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int64, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) int64); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_GetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersion'
type MockStoragePort_GetVersion_Call struct {
	*mock.Call
}

// GetVersion is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) GetVersion(key interface{}) *MockStoragePort_GetVersion_Call {
	return &MockStoragePort_GetVersion_Call{Call: _e.mock.On("GetVersion", key)}
}

func (_c *MockStoragePort_GetVersion_Call) Run(run func(key string)) *MockStoragePort_GetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_GetVersion_Call) Return(_a0 int64, _a1 error) *MockStoragePort_GetVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_GetVersion_Call) RunAndReturn(run func(string) (int64, error)) *MockStoragePort_GetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementVersion provides a mock function with given fields: key
func (_m *MockStoragePort) IncrementVersion(key string) (int64, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for IncrementVersion")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int64, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) int64); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_IncrementVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementVersion'
type MockStoragePort_IncrementVersion_Call struct {
	*mock.Call
}

// IncrementVersion is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) IncrementVersion(key interface{}) *MockStoragePort_IncrementVersion_Call {
	return &MockStoragePort_IncrementVersion_Call{Call: _e.mock.On("IncrementVersion", key)}
}

func (_c *MockStoragePort_IncrementVersion_Call) Run(run func(key string)) *MockStoragePort_IncrementVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_IncrementVersion_Call) Return(newVersion int64, err error) *MockStoragePort_IncrementVersion_Call {
	_c.Call.Return(newVersion, err)
	return _c
}

func (_c *MockStoragePort_IncrementVersion_Call) RunAndReturn(run func(string) (int64, error)) *MockStoragePort_IncrementVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ListByPrefix provides a mock function with given fields: prefix
func (_m *MockStoragePort) ListByPrefix(prefix string) ([]ports.KeyValueVersion, error) {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for ListByPrefix")
	}

	var r0 []ports.KeyValueVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]ports.KeyValueVersion, error)); ok {
		return rf(prefix)
	}
	if rf, ok := ret.Get(0).(func(string) []ports.KeyValueVersion); ok {
		r0 = rf(prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ports.KeyValueVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(prefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStoragePort_ListByPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByPrefix'
type MockStoragePort_ListByPrefix_Call struct {
	*mock.Call
}

// ListByPrefix is a helper method to define mock.On call
//   - prefix string
func (_e *MockStoragePort_Expecter) ListByPrefix(prefix interface{}) *MockStoragePort_ListByPrefix_Call {
	return &MockStoragePort_ListByPrefix_Call{Call: _e.mock.On("ListByPrefix", prefix)}
}

func (_c *MockStoragePort_ListByPrefix_Call) Run(run func(prefix string)) *MockStoragePort_ListByPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_ListByPrefix_Call) Return(_a0 []ports.KeyValueVersion, _a1 error) *MockStoragePort_ListByPrefix_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStoragePort_ListByPrefix_Call) RunAndReturn(run func(string) ([]ports.KeyValueVersion, error)) *MockStoragePort_ListByPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// Put provides a mock function with given fields: key, value, version
func (_m *MockStoragePort) Put(key string, value []byte, version int64) error {
	ret := _m.Called(key, value, version)

	if len(ret) == 0 {
		panic("no return value specified for Put")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []byte, int64) error); ok {
		r0 = rf(key, value, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type MockStoragePort_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//   - key string
//   - value []byte
//   - version int64
func (_e *MockStoragePort_Expecter) Put(key interface{}, value interface{}, version interface{}) *MockStoragePort_Put_Call {
	return &MockStoragePort_Put_Call{Call: _e.mock.On("Put", key, value, version)}
}

func (_c *MockStoragePort_Put_Call) Run(run func(key string, value []byte, version int64)) *MockStoragePort_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte), args[2].(int64))
	})
	return _c
}

func (_c *MockStoragePort_Put_Call) Return(_a0 error) *MockStoragePort_Put_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_Put_Call) RunAndReturn(run func(string, []byte, int64) error) *MockStoragePort_Put_Call {
	_c.Call.Return(run)
	return _c
}

// PutWithTTL provides a mock function with given fields: key, value, version, ttl
func (_m *MockStoragePort) PutWithTTL(key string, value []byte, version int64, ttl time.Duration) error {
	ret := _m.Called(key, value, version, ttl)

	if len(ret) == 0 {
		panic("no return value specified for PutWithTTL")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []byte, int64, time.Duration) error); ok {
		r0 = rf(key, value, version, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_PutWithTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutWithTTL'
type MockStoragePort_PutWithTTL_Call struct {
	*mock.Call
}

// PutWithTTL is a helper method to define mock.On call
//   - key string
//   - value []byte
//   - version int64
//   - ttl time.Duration
func (_e *MockStoragePort_Expecter) PutWithTTL(key interface{}, value interface{}, version interface{}, ttl interface{}) *MockStoragePort_PutWithTTL_Call {
	return &MockStoragePort_PutWithTTL_Call{Call: _e.mock.On("PutWithTTL", key, value, version, ttl)}
}

func (_c *MockStoragePort_PutWithTTL_Call) Run(run func(key string, value []byte, version int64, ttl time.Duration)) *MockStoragePort_PutWithTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte), args[2].(int64), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStoragePort_PutWithTTL_Call) Return(_a0 error) *MockStoragePort_PutWithTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_PutWithTTL_Call) RunAndReturn(run func(string, []byte, int64, time.Duration) error) *MockStoragePort_PutWithTTL_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreCompressedSnapshot provides a mock function with given fields: snapshot
func (_m *MockStoragePort) RestoreCompressedSnapshot(snapshot io.Reader) error {
	ret := _m.Called(snapshot)

	if len(ret) == 0 {
		panic("no return value specified for RestoreCompressedSnapshot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(io.Reader) error); ok {
		r0 = rf(snapshot)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_RestoreCompressedSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreCompressedSnapshot'
type MockStoragePort_RestoreCompressedSnapshot_Call struct {
	*mock.Call
}

// RestoreCompressedSnapshot is a helper method to define mock.On call
//   - snapshot io.Reader
func (_e *MockStoragePort_Expecter) RestoreCompressedSnapshot(snapshot interface{}) *MockStoragePort_RestoreCompressedSnapshot_Call {
	return &MockStoragePort_RestoreCompressedSnapshot_Call{Call: _e.mock.On("RestoreCompressedSnapshot", snapshot)}
}

func (_c *MockStoragePort_RestoreCompressedSnapshot_Call) Run(run func(snapshot io.Reader)) *MockStoragePort_RestoreCompressedSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(io.Reader))
	})
	return _c
}

func (_c *MockStoragePort_RestoreCompressedSnapshot_Call) Return(_a0 error) *MockStoragePort_RestoreCompressedSnapshot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_RestoreCompressedSnapshot_Call) RunAndReturn(run func(io.Reader) error) *MockStoragePort_RestoreCompressedSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreSnapshot provides a mock function with given fields: snapshot
func (_m *MockStoragePort) RestoreSnapshot(snapshot io.Reader) error {
	ret := _m.Called(snapshot)

	if len(ret) == 0 {
		panic("no return value specified for RestoreSnapshot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(io.Reader) error); ok {
		r0 = rf(snapshot)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_RestoreSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreSnapshot'
type MockStoragePort_RestoreSnapshot_Call struct {
	*mock.Call
}

// RestoreSnapshot is a helper method to define mock.On call
//   - snapshot io.Reader
func (_e *MockStoragePort_Expecter) RestoreSnapshot(snapshot interface{}) *MockStoragePort_RestoreSnapshot_Call {
	return &MockStoragePort_RestoreSnapshot_Call{Call: _e.mock.On("RestoreSnapshot", snapshot)}
}

func (_c *MockStoragePort_RestoreSnapshot_Call) Run(run func(snapshot io.Reader)) *MockStoragePort_RestoreSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(io.Reader))
	})
	return _c
}

func (_c *MockStoragePort_RestoreSnapshot_Call) Return(_a0 error) *MockStoragePort_RestoreSnapshot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_RestoreSnapshot_Call) RunAndReturn(run func(io.Reader) error) *MockStoragePort_RestoreSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// RunInTransaction provides a mock function with given fields: fn
func (_m *MockStoragePort) RunInTransaction(fn func(ports.Transaction) error) error {
	ret := _m.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for RunInTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(func(ports.Transaction) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStoragePort_RunInTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunInTransaction'
type MockStoragePort_RunInTransaction_Call struct {
	*mock.Call
}

// RunInTransaction is a helper method to define mock.On call
//   - fn func(ports.Transaction) error
func (_e *MockStoragePort_Expecter) RunInTransaction(fn interface{}) *MockStoragePort_RunInTransaction_Call {
	return &MockStoragePort_RunInTransaction_Call{Call: _e.mock.On("RunInTransaction", fn)}
}

func (_c *MockStoragePort_RunInTransaction_Call) Run(run func(fn func(ports.Transaction) error)) *MockStoragePort_RunInTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(ports.Transaction) error))
	})
	return _c
}

func (_c *MockStoragePort_RunInTransaction_Call) Return(_a0 error) *MockStoragePort_RunInTransaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStoragePort_RunInTransaction_Call) RunAndReturn(run func(func(ports.Transaction) error) error) *MockStoragePort_RunInTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SetRaftNode provides a mock function with given fields: node
func (_m *MockStoragePort) SetRaftNode(node ports.RaftNode) {
	_m.Called(node)
}

// MockStoragePort_SetRaftNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRaftNode'
type MockStoragePort_SetRaftNode_Call struct {
	*mock.Call
}

// SetRaftNode is a helper method to define mock.On call
//   - node ports.RaftNode
func (_e *MockStoragePort_Expecter) SetRaftNode(node interface{}) *MockStoragePort_SetRaftNode_Call {
	return &MockStoragePort_SetRaftNode_Call{Call: _e.mock.On("SetRaftNode", node)}
}

func (_c *MockStoragePort_SetRaftNode_Call) Run(run func(node ports.RaftNode)) *MockStoragePort_SetRaftNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ports.RaftNode))
	})
	return _c
}

func (_c *MockStoragePort_SetRaftNode_Call) Return() *MockStoragePort_SetRaftNode_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStoragePort_SetRaftNode_Call) RunAndReturn(run func(ports.RaftNode)) *MockStoragePort_SetRaftNode_Call {
	_c.Run(run)
	return _c
}

// Subscribe provides a mock function with given fields: prefix
func (_m *MockStoragePort) Subscribe(prefix string) (<-chan ports.StorageEvent, func(), error) {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 <-chan ports.StorageEvent
	var r1 func()
	var r2 error
	if rf, ok := ret.Get(0).(func(string) (<-chan ports.StorageEvent, func(), error)); ok {
		return rf(prefix)
	}
	if rf, ok := ret.Get(0).(func(string) <-chan ports.StorageEvent); ok {
		r0 = rf(prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan ports.StorageEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string) func()); ok {
		r1 = rf(prefix)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(prefix)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockStoragePort_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type MockStoragePort_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - prefix string
func (_e *MockStoragePort_Expecter) Subscribe(prefix interface{}) *MockStoragePort_Subscribe_Call {
	return &MockStoragePort_Subscribe_Call{Call: _e.mock.On("Subscribe", prefix)}
}

func (_c *MockStoragePort_Subscribe_Call) Run(run func(prefix string)) *MockStoragePort_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_Subscribe_Call) Return(_a0 <-chan ports.StorageEvent, _a1 func(), _a2 error) *MockStoragePort_Subscribe_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockStoragePort_Subscribe_Call) RunAndReturn(run func(string) (<-chan ports.StorageEvent, func(), error)) *MockStoragePort_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToKey provides a mock function with given fields: key
func (_m *MockStoragePort) SubscribeToKey(key string) (<-chan ports.StorageEvent, func(), error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToKey")
	}

	var r0 <-chan ports.StorageEvent
	var r1 func()
	var r2 error
	if rf, ok := ret.Get(0).(func(string) (<-chan ports.StorageEvent, func(), error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) <-chan ports.StorageEvent); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan ports.StorageEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string) func()); ok {
		r1 = rf(key)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(key)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockStoragePort_SubscribeToKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToKey'
type MockStoragePort_SubscribeToKey_Call struct {
	*mock.Call
}

// SubscribeToKey is a helper method to define mock.On call
//   - key string
func (_e *MockStoragePort_Expecter) SubscribeToKey(key interface{}) *MockStoragePort_SubscribeToKey_Call {
	return &MockStoragePort_SubscribeToKey_Call{Call: _e.mock.On("SubscribeToKey", key)}
}

func (_c *MockStoragePort_SubscribeToKey_Call) Run(run func(key string)) *MockStoragePort_SubscribeToKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStoragePort_SubscribeToKey_Call) Return(_a0 <-chan ports.StorageEvent, _a1 func(), _a2 error) *MockStoragePort_SubscribeToKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockStoragePort_SubscribeToKey_Call) RunAndReturn(run func(string) (<-chan ports.StorageEvent, func(), error)) *MockStoragePort_SubscribeToKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStoragePort creates a new instance of MockStoragePort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStoragePort(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStoragePort {
	mock := &MockStoragePort{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
