// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	badger "github.com/dgraph-io/badger/v3"

	domain "github.com/eleven-am/graft/internal/domain"

	mock "github.com/stretchr/testify/mock"

	ports "github.com/eleven-am/graft/internal/ports"
)

// MockRaftPort is an autogenerated mock type for the RaftPort type
type MockRaftPort struct {
	mock.Mock
}

type MockRaftPort_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRaftPort) EXPECT() *MockRaftPort_Expecter {
	return &MockRaftPort_Expecter{mock: &_m.Mock}
}

// Apply provides a mock function with given fields: ctx, command
func (_m *MockRaftPort) Apply(ctx context.Context, command *domain.Command) (*domain.CommandResult, error) {
	ret := _m.Called(ctx, command)

	if len(ret) == 0 {
		panic("no return value specified for Apply")
	}

	var r0 *domain.CommandResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Command) (*domain.CommandResult, error)); ok {
		return rf(ctx, command)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Command) *domain.CommandResult); ok {
		r0 = rf(ctx, command)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.CommandResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *domain.Command) error); ok {
		r1 = rf(ctx, command)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRaftPort_Apply_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Apply'
type MockRaftPort_Apply_Call struct {
	*mock.Call
}

// Apply is a helper method to define mock.On call
//   - ctx context.Context
//   - command *domain.Command
func (_e *MockRaftPort_Expecter) Apply(ctx interface{}, command interface{}) *MockRaftPort_Apply_Call {
	return &MockRaftPort_Apply_Call{Call: _e.mock.On("Apply", ctx, command)}
}

func (_c *MockRaftPort_Apply_Call) Run(run func(ctx context.Context, command *domain.Command)) *MockRaftPort_Apply_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Command))
	})
	return _c
}

func (_c *MockRaftPort_Apply_Call) Return(_a0 *domain.CommandResult, _a1 error) *MockRaftPort_Apply_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRaftPort_Apply_Call) RunAndReturn(run func(context.Context, *domain.Command) (*domain.CommandResult, error)) *MockRaftPort_Apply_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterInfo provides a mock function with no fields
func (_m *MockRaftPort) GetClusterInfo() ports.ClusterInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetClusterInfo")
	}

	var r0 ports.ClusterInfo
	if rf, ok := ret.Get(0).(func() ports.ClusterInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ports.ClusterInfo)
	}

	return r0
}

// MockRaftPort_GetClusterInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterInfo'
type MockRaftPort_GetClusterInfo_Call struct {
	*mock.Call
}

// GetClusterInfo is a helper method to define mock.On call
func (_e *MockRaftPort_Expecter) GetClusterInfo() *MockRaftPort_GetClusterInfo_Call {
	return &MockRaftPort_GetClusterInfo_Call{Call: _e.mock.On("GetClusterInfo")}
}

func (_c *MockRaftPort_GetClusterInfo_Call) Run(run func()) *MockRaftPort_GetClusterInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRaftPort_GetClusterInfo_Call) Return(_a0 ports.ClusterInfo) *MockRaftPort_GetClusterInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_GetClusterInfo_Call) RunAndReturn(run func() ports.ClusterInfo) *MockRaftPort_GetClusterInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetLeader provides a mock function with no fields
func (_m *MockRaftPort) GetLeader() (string, string) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLeader")
	}

	var r0 string
	var r1 string
	if rf, ok := ret.Get(0).(func() (string, string)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// MockRaftPort_GetLeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLeader'
type MockRaftPort_GetLeader_Call struct {
	*mock.Call
}

// GetLeader is a helper method to define mock.On call
func (_e *MockRaftPort_Expecter) GetLeader() *MockRaftPort_GetLeader_Call {
	return &MockRaftPort_GetLeader_Call{Call: _e.mock.On("GetLeader")}
}

func (_c *MockRaftPort_GetLeader_Call) Run(run func()) *MockRaftPort_GetLeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRaftPort_GetLeader_Call) Return(nodeID string, address string) *MockRaftPort_GetLeader_Call {
	_c.Call.Return(nodeID, address)
	return _c
}

func (_c *MockRaftPort_GetLeader_Call) RunAndReturn(run func() (string, string)) *MockRaftPort_GetLeader_Call {
	_c.Call.Return(run)
	return _c
}

// GetStateDB provides a mock function with no fields
func (_m *MockRaftPort) GetStateDB() *badger.DB {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetStateDB")
	}

	var r0 *badger.DB
	if rf, ok := ret.Get(0).(func() *badger.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*badger.DB)
		}
	}

	return r0
}

// MockRaftPort_GetStateDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStateDB'
type MockRaftPort_GetStateDB_Call struct {
	*mock.Call
}

// GetStateDB is a helper method to define mock.On call
func (_e *MockRaftPort_Expecter) GetStateDB() *MockRaftPort_GetStateDB_Call {
	return &MockRaftPort_GetStateDB_Call{Call: _e.mock.On("GetStateDB")}
}

func (_c *MockRaftPort_GetStateDB_Call) Run(run func()) *MockRaftPort_GetStateDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRaftPort_GetStateDB_Call) Return(_a0 *badger.DB) *MockRaftPort_GetStateDB_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_GetStateDB_Call) RunAndReturn(run func() *badger.DB) *MockRaftPort_GetStateDB_Call {
	_c.Call.Return(run)
	return _c
}

// IsLeader provides a mock function with no fields
func (_m *MockRaftPort) IsLeader() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsLeader")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockRaftPort_IsLeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsLeader'
type MockRaftPort_IsLeader_Call struct {
	*mock.Call
}

// IsLeader is a helper method to define mock.On call
func (_e *MockRaftPort_Expecter) IsLeader() *MockRaftPort_IsLeader_Call {
	return &MockRaftPort_IsLeader_Call{Call: _e.mock.On("IsLeader")}
}

func (_c *MockRaftPort_IsLeader_Call) Run(run func()) *MockRaftPort_IsLeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRaftPort_IsLeader_Call) Return(_a0 bool) *MockRaftPort_IsLeader_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_IsLeader_Call) RunAndReturn(run func() bool) *MockRaftPort_IsLeader_Call {
	_c.Call.Return(run)
	return _c
}

// Join provides a mock function with given fields: peers
func (_m *MockRaftPort) Join(peers []ports.Peer) error {
	ret := _m.Called(peers)

	if len(ret) == 0 {
		panic("no return value specified for Join")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]ports.Peer) error); ok {
		r0 = rf(peers)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRaftPort_Join_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Join'
type MockRaftPort_Join_Call struct {
	*mock.Call
}

// Join is a helper method to define mock.On call
//   - peers []ports.Peer
func (_e *MockRaftPort_Expecter) Join(peers interface{}) *MockRaftPort_Join_Call {
	return &MockRaftPort_Join_Call{Call: _e.mock.On("Join", peers)}
}

func (_c *MockRaftPort_Join_Call) Run(run func(peers []ports.Peer)) *MockRaftPort_Join_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]ports.Peer))
	})
	return _c
}

func (_c *MockRaftPort_Join_Call) Return(_a0 error) *MockRaftPort_Join_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_Join_Call) RunAndReturn(run func([]ports.Peer) error) *MockRaftPort_Join_Call {
	_c.Call.Return(run)
	return _c
}

// Leave provides a mock function with no fields
func (_m *MockRaftPort) Leave() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Leave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRaftPort_Leave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Leave'
type MockRaftPort_Leave_Call struct {
	*mock.Call
}

// Leave is a helper method to define mock.On call
func (_e *MockRaftPort_Expecter) Leave() *MockRaftPort_Leave_Call {
	return &MockRaftPort_Leave_Call{Call: _e.mock.On("Leave")}
}

func (_c *MockRaftPort_Leave_Call) Run(run func()) *MockRaftPort_Leave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRaftPort_Leave_Call) Return(_a0 error) *MockRaftPort_Leave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_Leave_Call) RunAndReturn(run func() error) *MockRaftPort_Leave_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function with given fields: ctx, existingPeers
func (_m *MockRaftPort) Start(ctx context.Context, existingPeers []ports.Peer) error {
	ret := _m.Called(ctx, existingPeers)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []ports.Peer) error); ok {
		r0 = rf(ctx, existingPeers)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRaftPort_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockRaftPort_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
//   - existingPeers []ports.Peer
func (_e *MockRaftPort_Expecter) Start(ctx interface{}, existingPeers interface{}) *MockRaftPort_Start_Call {
	return &MockRaftPort_Start_Call{Call: _e.mock.On("Start", ctx, existingPeers)}
}

func (_c *MockRaftPort_Start_Call) Run(run func(ctx context.Context, existingPeers []ports.Peer)) *MockRaftPort_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]ports.Peer))
	})
	return _c
}

func (_c *MockRaftPort_Start_Call) Return(_a0 error) *MockRaftPort_Start_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_Start_Call) RunAndReturn(run func(context.Context, []ports.Peer) error) *MockRaftPort_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function with no fields
func (_m *MockRaftPort) Stop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRaftPort_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockRaftPort_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *MockRaftPort_Expecter) Stop() *MockRaftPort_Stop_Call {
	return &MockRaftPort_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *MockRaftPort_Stop_Call) Run(run func()) *MockRaftPort_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRaftPort_Stop_Call) Return(_a0 error) *MockRaftPort_Stop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_Stop_Call) RunAndReturn(run func() error) *MockRaftPort_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForLeader provides a mock function with given fields: ctx
func (_m *MockRaftPort) WaitForLeader(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WaitForLeader")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRaftPort_WaitForLeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForLeader'
type MockRaftPort_WaitForLeader_Call struct {
	*mock.Call
}

// WaitForLeader is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRaftPort_Expecter) WaitForLeader(ctx interface{}) *MockRaftPort_WaitForLeader_Call {
	return &MockRaftPort_WaitForLeader_Call{Call: _e.mock.On("WaitForLeader", ctx)}
}

func (_c *MockRaftPort_WaitForLeader_Call) Run(run func(ctx context.Context)) *MockRaftPort_WaitForLeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRaftPort_WaitForLeader_Call) Return(_a0 error) *MockRaftPort_WaitForLeader_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRaftPort_WaitForLeader_Call) RunAndReturn(run func(context.Context) error) *MockRaftPort_WaitForLeader_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRaftPort creates a new instance of MockRaftPort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRaftPort(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRaftPort {
	mock := &MockRaftPort{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
